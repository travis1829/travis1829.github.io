---
---

@inproceedings{intervalvm,
abbr={SOSP},
author = {Kim, Tae Woo and Kwon, Youngjin and Kang, Jeehoon},
title = {Scalable Address Spaces using Concurrent Interval Skiplist},
year = {2025},
isbn = {9798400718700},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3731569.3764807},
abstract = {A kernel's address space design can significantly bottleneck multi-threaded applications, as address space operations such as mmap() and munmap() are serialized by coarse-grained locks like Linux's mmap_lock. Such locks have long been known as one of the most intractable contention points in memory management. While prior works have attempted to address this issue, they either fail to sufficiently parallelize operations or are impractical for real-world kernels.

We present the first scalable and practical address space design that parallelizes critical operations. We identify key scalability bottlenecks—many of which extend beyond address spaces—and address them with targeted solutions. At its core is the concurrent interval skiplist, a new data structure that integrates mapping and locking for parallel interval operations. We implement our design on Linux 6.8 and evaluate it on a dual-socket 48-core machine. Our results show a significant throughput improvement of 13.1× for an mmap() microbenchmark, 4.49× for LevelDB, 3.19× for the Apache web server, 1.47× for Metis MapReduce, and 1.27× for Psearchy text indexing.},
booktitle = {Proceedings of the ACM SIGOPS 31st Symposium on Operating Systems Principles (Accepted)},
location = {Seoul, Republic of Korea},
series = {SOSP '25},
artifact = {https://github.com/kaist-cp/interval-vm},
selected = {true},
}
# doi = {10.1145/3731569.3764807},

@article{rv6,
abbr={SCICO},
title = {Taming shared mutable states of operating systems in Rust},
journal = {Science of Computer Programming},
volume = {238},
pages = {103152},
year = {2024},
issn = {0167-6423},
doi = {https://doi.org/10.1016/j.scico.2024.103152},
url = {https://www.sciencedirect.com/science/article/pii/S0167642324000753},
author = {Jaemin Hong and Sunghwan Shim and Sanguk Park and Tae Woo Kim and Jungwoo Kim and Junsoo Lee and Sukyoung Ryu and Jeehoon Kang},
keywords = {Shared mutable state, Operating system, Rust},
abstract = {Operating systems (OSs) suffer from pervasive memory bugs. Their primary source is shared mutable states, crucial to low-level control and efficiency. The safety of shared mutable states is not guaranteed by C/C++, in which legacy OSs are typically written. Recently, researchers have adopted Rust into OS development to implement clean-slate OSs with fewer memory bugs. Rust ensures the safety of shared mutable states that follow the “aliasing XOR mutability” discipline via its type system. With the success of Rust in clean-slate OSs, the industry has become interested in rewriting legacy OSs in Rust. However, one of the most significant obstacles to this goal is shared mutable states that are aliased AND mutable (A&M). While they are essential to the performance of legacy OSs, Rust does not guarantee their safety. Instead, programmers have identified A&M states with the same reasoning principle dubbed an A&M pattern and implemented its modular abstraction to facilitate safety reasoning. This paper investigates modular abstractions for A&M patterns in legacy OSs. We present modular abstractions for six A&M patterns in the xv6 OS. Our investigation of Linux and clean-slate Rust OSs shows that the patterns are practical, as all of them are utilized in Linux, and the abstractions are original, as none of them are found in the Rust OSs. Using the abstractions, we implemented xv6Rust, a complete rewrite of xv6 in Rust. The abstractions incur no run-time overhead compared to xv6 while reducing the reasoning cost of xv6Rust to the level of the clean-slate Rust OSs.},
artifact = {https://github.com/kaist-cp/rv6},
selected = {true},
}
